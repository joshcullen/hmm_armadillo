tmp<- matrix(NA, nrow(dat[[i]]), 2)
if (length(int) == 1) {  #when using only 1 time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol)) {
tmp[j, 1:2]<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "hours")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
} else {  #when using more than one time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (sum(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol)) > 0) {
ind<- which(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol))
tmp[j, 1:2]<- c(int[ind], as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "seconds")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
}
dat[[i]]$dt<- tmp[,1]
dat[[i]]$date<- tmp[,2] %>%
as.POSIXct(origin = '1970-01-01', tz = time.zone)
}
dat<- dplyr::bind_rows(dat)
dat
}
#filter obs for primary time step (300 s)
dat2<- bayesmove::round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
#filter obs for primary time step (300 s)
dat2<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
round_track_time = function(dat, id, dt, date, int, tol, time.zone = "UTC") {
dat<- bayesmove::df_to_list(dat, ind = id)
for (i in 1:length(dat)) {
tmp<- matrix(NA, nrow(dat[[i]]), 2)
if (length(int) == 1) {  #when using only 1 time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol)) {
tmp[j, 1:2]<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "hours")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
} else {  #when using more than one time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (sum(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol)) > 0) {
ind<- which(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol))
tmp[j, 1:2]<- c(int[ind], as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "seconds")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
}
dat[[i]]$dt<- tmp[,1]
dat[[i]]$date<- tmp[,2] %>%
as.POSIXct(origin = '1970-01-01', tz = time.zone)
}
dat<- dplyr::bind_rows(dat)
dat
}
#filter obs for primary time step (300 s)
dat2<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
View(dat)
View(dat2)
glimpse(dat)
id="id"
dt="dt"
date="date"
int=300
tol=60
time.zone = "UTC"
dat.orig<- dat
dat<- bayesmove::df_to_list(dat, ind = id)
length(dat)
i=1
tmp<- matrix(NA, nrow(dat[[i]]), 2)
length(int)
j=1
is.na(dat[[i]]$dt[j])
dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol)
as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "hours"))
round_track_time = function(dat, id, dt, date, int, tol, time.zone = "UTC") {
dat<- bayesmove::df_to_list(dat, ind = id)
for (i in 1:length(dat)) {
tmp<- matrix(NA, nrow(dat[[i]]), 2)
if (length(int) == 1) {  #when using only 1 time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) {
tmp[j, 1:2]<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "seconds")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
} else {  #when using more than one time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (sum(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) > 0) {
ind<- which(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int)
tmp[j, 1:2]<- c(int[ind], as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "seconds")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
}
dat[[i]]$dt<- tmp[,1]
dat[[i]]$date<- tmp[,2] %>%
as.POSIXct(origin = '1970-01-01', tz = time.zone)
}
dat<- dplyr::bind_rows(dat)
dat
}
#filter obs for primary time step (300 s)
dat2<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
dat<- dat.orig
#filter obs for primary time step (300 s)
dat2<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
round_track_time = function(dat, id, dt, date, int, tol, time.zone = "UTC") {
dat<- bayesmove::df_to_list(dat, ind = id)
for (i in 1:length(dat)) {
tmp<- matrix(NA, nrow(dat[[i]]), 2)
if (length(int) == 1) {  #when using only 1 time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) {
tmp[j, 1:2]<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "secs")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
} else {  #when using more than one time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (sum(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) > 0) {
ind<- which(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int)
tmp[j, 1:2]<- c(int[ind], as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "secs")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
}
dat[[i]]$dt<- tmp[,1]
dat[[i]]$date<- tmp[,2] %>%
as.POSIXct(origin = '1970-01-01', tz = time.zone)
}
dat<- dplyr::bind_rows(dat)
dat
}
#filter obs for primary time step (300 s)
dat2<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
round_track_time = function(dat, id, dt, date, int, tol, time.zone = "UTC") {
dat<- bayesmove::df_to_list(dat, ind = id)
for (i in 1:length(dat)) {
tmp<- matrix(NA, nrow(dat[[i]]), 2)
if (length(int) == 1) {  #when using only 1 time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) {
tmp[j, 1:2]<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "mins")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
} else {  #when using more than one time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (sum(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) > 0) {
ind<- which(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int)
tmp[j, 1:2]<- c(int[ind], as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "mins")))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
}
dat[[i]]$dt<- tmp[,1]
dat[[i]]$date<- tmp[,2] %>%
as.POSIXct(origin = '1970-01-01', tz = time.zone)
}
dat<- dplyr::bind_rows(dat)
dat
}
#filter obs for primary time step (300 s)
dat2<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
dat<- bayesmove::df_to_list(dat, ind = id)
tmp<- matrix(NA, nrow(dat[[i]]), 2)
dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int
j=2
dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int
j=3
dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int
c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "mins")))
foo<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "mins")))
foo[2]
foo[2] %>% as.POSIXct(origin = '1970-01-01', tz = time.zone)
foo<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "secs")))
foo
foo<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "hours")))
foo
foo[2] %>% as.POSIXct(origin = '1970-01-01', tz = time.zone)
foo<- c(int, as.numeric(round.POSIXt(dat[[i]]$date[j],
units = "secs")))
foo[2] %>% as.POSIXct(origin = '1970-01-01', tz = time.zone)
dat[[i]]$date[j]
dat[[i]]$date[j] + 60
dat[[i]]$date[j] - (int - tol)
dat[[i]]$date[j] - (tol - int)
dat[[i]]$date[j] - (dt - int)
dat[[i]]$date[j] - (dat[[i]]$dt[j] - int)
dat[[i]]$date[j] - (360 - int)
dat[[i]]$date[j] - (dat[[i]]$"dt"[j] - int)
tmp<- matrix(NA, nrow(dat[[i]]), 2)
if (length(int) == 1) {  #when using only 1 time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) {
tmp[j, 1:2]<- c(int, dat[[i]]$date[j] - (dat[[i]]$dt[j] - int))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
} else {  #when using more than one time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (sum(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) > 0) {
ind<- which(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int)
tmp[j, 1:2]<- c(int[ind], dat[[i]]$date[j] - (dat[[i]]$dt[j] - int))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
}
View(tmp)
tmp[,2] %>%
as.POSIXct(origin = '1970-01-01', tz = time.zone)
round_track_time = function(dat, id, dt, date, int, tol, time.zone = "UTC") {
dat<- bayesmove::df_to_list(dat, ind = id)
for (i in 1:length(dat)) {
tmp<- matrix(NA, nrow(dat[[i]]), 2)
if (length(int) == 1) {  #when using only 1 time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) {
tmp[j, 1:2]<- c(int, dat[[i]]$date[j] - (dat[[i]]$dt[j] - int))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
} else {  #when using more than one time interval
for (j in 1:nrow(dat[[i]])) {
if (is.na(dat[[i]]$dt[j])) {
tmp[j, 1:2]<- NA
} else if (sum(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int) > 0) {
ind<- which(dat[[i]]$dt[j] >= (int - tol) & dat[[i]]$dt[j] <= (int + tol) &
dat[[i]]$dt[j] != int)
tmp[j, 1:2]<- c(int[ind], dat[[i]]$date[j] - (dat[[i]]$dt[j] - int))
} else {
tmp[j, 1:2]<- c(dat[[i]]$dt[j], dat[[i]]$date[j])
}
}
}
dat[[i]]$dt<- tmp[,1]
dat[[i]]$date<- tmp[,2] %>%
as.POSIXct(origin = '1970-01-01', tz = time.zone)
}
dat<- dplyr::bind_rows(dat)
dat
}
dat<- dat.orig
#filter obs for primary time step (300 s)
dat2<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
bayesmove::ronud_track_time
bayesmove::round_track_time
View(dat)
#filter obs for primary time step (300 s)
dat<- round_track_time(dat, "id", "dt", "date", 300, 60, time.zone = "UTC")
dat<- dat[dat$dt == 300,]
#Explore distribution of SL and TA
ggplot(dat, aes(step)) +
geom_density(fill = "cadetblue") +
theme_bw()
summary(dat$step)
ggplot(dat, aes(angle)) +
geom_density(fill = "firebrick") +
theme_bw()
#Log-transform SL and logit-transform abs. value of pi-scaled TA
dat<- transform_data(dat = dat)
#remove all obs where log.SL or logit.TA are NA
dat<- dat[!is.na(dat$log.SL),]
dat<- dat[!is.na(dat$logit.TA),]
summary(dat$step)
#Explore transformed distribution of SL and TA
ggplot(dat, aes(log.SL)) +
geom_density(fill = "cadetblue") +
theme_bw()
ggplot(dat, aes(logit.TA)) +
geom_density(fill = "firebrick") +
theme_bw()
#priors
var.mu=100
sig2.a=0.1; sig2.b=0.1
gamma1=0.1
#initialize parameters
max.group=7
#MCMC stuff
ngibbs=3000
nburn=ngibbs/2
tic()
mod=hmm.main.function(dat=dat,var.mu=var.mu,sig2.a=sig2.a,sig2.b=sig2.b,
gamma1=gamma1,max.group=max.group,
ngibbs=ngibbs,nburn=nburn)
toc()
View(dat)
1985/60
View(mod)
#check traceplot of log-likelihood
plot(mod$llk, type='l')
#inpsect boxplot of thetas
boxplot(mod$theta[(nburn + 1):ngibbs,])
colMeans(mod$theta[(nburn + 1):ngibbs,]) %>% cumsum()  #suggests 4 active states
MAP.est<- which.max(mod$llk[(nburn + 1):ngibbs]) + nburn
behav.params<- mod %>%
keep(names(.) == names(.)[1:4]) %>%
map(., as.data.frame) %>%
map(., select, 1:7) %>%
map(., slice, MAP.est) %>%
bind_rows() %>%
t() %>%
data.frame() %>%
mutate(behav = 1:7)
names(behav.params)[1:4]<- names(mod)[1:4]
plot_data_SL<-
pmap_df(behav.params[,-c(1,3)],
function(mu.sk, sig2.sk, behav) {
tibble(y = exp(rnorm(1000, mean = mu.sk, sd = sqrt(sig2.sk))),
behav = behav)
})
plot_data_SL$behav<- factor(plot_data_SL$behav)
plot_data_TA<-
pmap_df(behav.params[,-c(2,4)],
function(mu.ak, sig2.ak, behav) {
tibble(y = plogis(rnorm(1000, mean = mu.ak, sd = sqrt(sig2.ak))) * pi,
behav = behav)
})
plot_data_TA$behav<- factor(plot_data_TA$behav)
# Plot overlapping densities per behavior (step lengths)
ggplot(data = plot_data_SL, aes(color = behav)) +
geom_density(aes(group = behav, x = y), alpha = 0.4, size = 1) +
labs(x = "\nStep Length (m)", y = "Density\n") +
scale_color_brewer("", palette = "Dark2") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
strip.text = element_text(size = 12),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10))
View(behav.params)
behav.params<- mod %>%
keep(names(.) == names(.)[1:4]) %>%
map(., as.data.frame) %>%
map(., select, 1:6) %>%
map(., slice, MAP.est) %>%
bind_rows() %>%
t() %>%
data.frame() %>%
mutate(behav = 1:6)
names(behav.params)[1:4]<- names(mod)[1:4]
plot_data_SL<-
pmap_df(behav.params[,-c(1,3)],
function(mu.sk, sig2.sk, behav) {
tibble(y = exp(rnorm(1000, mean = mu.sk, sd = sqrt(sig2.sk))),
behav = behav)
})
plot_data_SL$behav<- factor(plot_data_SL$behav)
plot_data_TA<-
pmap_df(behav.params[,-c(2,4)],
function(mu.ak, sig2.ak, behav) {
tibble(y = plogis(rnorm(1000, mean = mu.ak, sd = sqrt(sig2.ak))) * pi,
behav = behav)
})
plot_data_TA$behav<- factor(plot_data_TA$behav)
# Plot overlapping densities per behavior (step lengths)
ggplot(data = plot_data_SL, aes(color = behav)) +
geom_density(aes(group = behav, x = y), alpha = 0.4, size = 1) +
labs(x = "\nStep Length (m)", y = "Density\n") +
scale_color_brewer("", palette = "Dark2") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
strip.text = element_text(size = 12),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10))
# Plot turning angle
ggplot(data = plot_data_TA, aes(color = behav)) +
geom_density(aes(group = behav, x = y), alpha = 0.4, size = 1) +
labs(x = "\nTurning Angle (rad)", y = "Density\n") +
scale_color_brewer("", palette = "Dark2") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
strip.text = element_text(size = 12),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10))
behav.params<- mod %>%
keep(names(.) == names(.)[1:4]) %>%
map(., as.data.frame) %>%
map(., select, 1:3) %>%
map(., slice, MAP.est) %>%
bind_rows() %>%
t() %>%
data.frame() %>%
mutate(behav = 1:3)
names(behav.params)[1:4]<- names(mod)[1:4]
plot_data_SL<-
pmap_df(behav.params[,-c(1,3)],
function(mu.sk, sig2.sk, behav) {
tibble(y = exp(rnorm(1000, mean = mu.sk, sd = sqrt(sig2.sk))),
behav = behav)
})
plot_data_SL$behav<- factor(plot_data_SL$behav)
plot_data_TA<-
pmap_df(behav.params[,-c(2,4)],
function(mu.ak, sig2.ak, behav) {
tibble(y = plogis(rnorm(1000, mean = mu.ak, sd = sqrt(sig2.ak))) * pi,
behav = behav)
})
plot_data_TA$behav<- factor(plot_data_TA$behav)
# Plot overlapping densities per behavior (step lengths)
ggplot(data = plot_data_SL, aes(color = behav)) +
geom_density(aes(group = behav, x = y), alpha = 0.4, size = 1) +
labs(x = "\nStep Length (m)", y = "Density\n") +
scale_color_brewer("", palette = "Dark2") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
strip.text = element_text(size = 12),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10))
# Plot turning angle
ggplot(data = plot_data_TA, aes(color = behav)) +
geom_density(aes(group = behav, x = y), alpha = 0.4, size = 1) +
labs(x = "\nTurning Angle (rad)", y = "Density\n") +
scale_color_brewer("", palette = "Dark2") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 14),
strip.text = element_text(size = 12),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10))
colMeans(mod$theta[(nburn + 1):ngibbs,]) %>% cumsum()  #suggests 3 active states
colMeans(mod$theta[(nburn + 1):ngibbs,])
# Viz mapped behaviors
dat$behav<- factor(mod$z.k)
ggplot() +
geom_point(data = dat %>% filter(behav == 1), aes(x, y, color = behav), size = 2,
alpha = 0.6) +
theme_bw() +
scale_color_brewer("Behavior", palette = "Dark2") +
facet_wrap(~id, scales = "free")
ggplot() +
geom_point(data = dat, aes(x, y, color = behav), size = 2,
alpha = 0.6) +
theme_bw() +
scale_color_brewer("Behavior", palette = "Dark2") +
facet_wrap(~id, scales = "free")
